Index: main/snake_game.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\nimport sys\nimport random\n\nimport numpy as np\n\nos.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = '1'\nimport pygame\nfrom pygame import mixer\n\nclass SnakeGame:\n    def __init__(self, seed=0, board_size=12, silent_mode=True):\n        self.board_size = board_size\n        self.grid_size = self.board_size ** 2\n        self.cell_size = 40\n        self.width = self.height = self.board_size * self.cell_size\n\n        self.border_size = 20\n        self.display_width = self.width + 2 * self.border_size\n        self.display_height = self.height + 2 * self.border_size + 40\n\n        self.silent_mode = silent_mode\n        if not silent_mode:\n            pygame.init()\n            pygame.display.set_caption(\"Snake Game\")\n            self.screen = pygame.display.set_mode((self.display_width, self.display_height))\n            self.font = pygame.font.Font(None, 36)\n\n            # Load sound effects\n            mixer.init()\n            self.sound_eat = mixer.Sound(\"sound/eat.wav\")\n            self.sound_game_over = mixer.Sound(\"sound/game_over.wav\")\n            self.sound_victory = mixer.Sound(\"sound/victory.wav\")\n        else:\n            self.screen = None\n            self.font = None\n\n        self.snake = None\n        self.non_snake = None\n\n        self.direction = None\n        self.score = 0\n        self.food = None\n        self.seed_value = seed\n\n        random.seed(seed) # Set random seed.\n        \n        self.reset()\n\n    def reset(self):\n        self.snake = [(self.board_size // 2 + i, self.board_size // 2) for i in range(1, -2, -1)] # Initialize the snake with three cells in (row, column) format.\n        self.non_snake = set([(row, col) for row in range(self.board_size) for col in range(self.board_size) if (row, col) not in self.snake]) # Initialize the non-snake cells.\n        self.direction = \"DOWN\" # Snake starts downward in each round\n        self.food = self._generate_food()\n        self.score = 0\n\n    def step(self, action):\n        self._update_direction(action) # Update direction based on action.\n\n        # Move snake based on current action.\n        row, col = self.snake[0]\n        if self.direction == \"UP\":\n            row -= 1\n        elif self.direction == \"DOWN\":\n            row += 1\n        elif self.direction == \"LEFT\":\n            col -= 1\n        elif self.direction == \"RIGHT\":\n            col += 1\n\n        # Check if snake eats food.\n        if (row, col) == self.food: # If snake eats food, it won't pop the last cell. The food grid will be taken by snake later, no need to update board vacancy matrix.\n            food_obtained = True\n            self.score += 10 # Add 10 points to the score when food is eaten.\n            if not self.silent_mode:\n                self.sound_eat.play()\n        else:\n            food_obtained = False\n            self.non_snake.add(self.snake.pop()) # Pop the last cell of the snake and add it to the non-snake set.\n\n        # Check if snake collided with itself or the wall\n        done = (\n            (row, col) in self.snake\n            or row < 0\n            or row >= self.board_size\n            or col < 0\n            or col >= self.board_size\n        )\n\n        if not done:\n            self.snake.insert(0, (row, col))\n            self.non_snake.remove((row, col))\n\n        else: # If game is over and the game is not in silent mode, play game over sound effect.\n            if not self.silent_mode:\n                if len(self.snake) < self.grid_size:\n                    self.sound_game_over.play()\n                else:\n                    self.sound_victory.play()\n\n        # Add new food after snake movement completes.\n        if food_obtained:\n            self.food = self._generate_food()\n\n        info ={\n            \"snake_size\": len(self.snake),\n            \"snake_head_pos\": np.array(self.snake[0]),\n            \"prev_snake_head_pos\": np.array(self.snake[1]),\n            \"food_pos\": np.array(self.food),\n            \"food_obtained\": food_obtained\n        }\n\n        return done, info\n\n    # 0: UP, 1: LEFT, 2: RIGHT, 3: DOWN\n    def _update_direction(self, action):\n        if action == 0:\n            if self.direction != \"DOWN\":\n                self.direction = \"UP\"\n        elif action == 1:\n            if self.direction != \"RIGHT\":\n                self.direction = \"LEFT\"\n        elif action == 2:\n            if self.direction != \"LEFT\":\n                self.direction = \"RIGHT\"\n        elif action == 3:\n            if self.direction != \"UP\":\n                self.direction = \"DOWN\"\n        # Swich Case is supported in Python 3.10+\n\n    def _generate_food(self):\n        if len(self.non_snake) > 0:\n            food = random.sample(self.non_snake, 1)[0]\n        else: # If the snake occupies the entire board, no need to generate new food and just default to (0, 0).\n            food = (0, 0)\n        return food\n    \n    def draw_score(self):\n        score_text = self.font.render(f\"Score: {self.score}\", True, (255, 255, 255))\n        self.screen.blit(score_text, (self.border_size, self.height + 2 * self.border_size))\n    \n    def draw_welcome_screen(self):\n        title_text = self.font.render(\"SNAKE GAME\", True, (255, 255, 255))\n        start_button_text = \"START\"\n\n        self.screen.fill((0, 0, 0))\n        self.screen.blit(title_text, (self.display_width // 2 - title_text.get_width() // 2, self.display_height // 4))\n        self.draw_button_text(start_button_text, (self.display_width // 2, self.display_height // 2))\n        pygame.display.flip()\n\n    def draw_game_over_screen(self):\n        game_over_text = self.font.render(\"GAME OVER\", True, (255, 255, 255))\n        final_score_text = self.font.render(f\"SCORE: {self.score}\", True, (255, 255, 255))\n        retry_button_text = \"RETRY\"\n\n        self.screen.fill((0, 0, 0))\n        self.screen.blit(game_over_text, (self.display_width // 2 - game_over_text.get_width() // 2, self.display_height // 4))\n        self.screen.blit(final_score_text, (self.display_width // 2 - final_score_text.get_width() // 2, self.display_height // 4 + final_score_text.get_height() + 10))\n        self.draw_button_text(retry_button_text, (self.display_width // 2, self.display_height // 2))          \n        pygame.display.flip()\n\n    def draw_button_text(self, button_text_str, pos, hover_color=(255, 255, 255), normal_color=(100, 100, 100)):\n        mouse_pos = pygame.mouse.get_pos()\n        button_text = self.font.render(button_text_str, True, normal_color)\n        text_rect = button_text.get_rect(center=pos)\n        \n        if text_rect.collidepoint(mouse_pos):\n            colored_text = self.font.render(button_text_str, True, hover_color)\n        else:\n            colored_text = self.font.render(button_text_str, True, normal_color)\n        \n        self.screen.blit(colored_text, text_rect)\n    \n    def draw_countdown(self, number):\n        countdown_text = self.font.render(str(number), True, (255, 255, 255))\n        self.screen.blit(countdown_text, (self.display_width // 2 - countdown_text.get_width() // 2, self.display_height // 2 - countdown_text.get_height() // 2))\n        pygame.display.flip()\n\n    def is_mouse_on_button(self, button_text):\n        mouse_pos = pygame.mouse.get_pos()\n        text_rect = button_text.get_rect(\n            center=(\n                self.display_width // 2,\n                self.display_height // 2,\n            )\n        )\n        return text_rect.collidepoint(mouse_pos)\n\n    def render(self):\n        self.screen.fill((0, 0, 0))\n\n        # Draw border\n        pygame.draw.rect(self.screen, (255, 255, 255), (self.border_size - 2, self.border_size - 2, self.width + 4, self.height + 4), 2)\n\n        # Draw snake\n        self.draw_snake()\n        \n        # Draw food\n        if len(self.snake) < self.grid_size: # If the snake occupies the entire board, don't draw food.\n            r, c = self.food\n            pygame.draw.rect(self.screen, (255, 0, 0), (c * self.cell_size + self.border_size, r * self.cell_size + self.border_size, self.cell_size, self.cell_size))\n\n        # Draw score\n        self.draw_score()\n\n        pygame.display.flip()\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n    def draw_snake(self):\n        # Draw the head\n        head_r, head_c = self.snake[0]\n        head_x = head_c * self.cell_size + self.border_size\n        head_y = head_r * self.cell_size + self.border_size\n\n        # Draw the head (Blue)\n        pygame.draw.polygon(self.screen, (100, 100, 255), [\n            (head_x + self.cell_size // 2, head_y),\n            (head_x + self.cell_size, head_y + self.cell_size // 2),\n            (head_x + self.cell_size // 2, head_y + self.cell_size),\n            (head_x, head_y + self.cell_size // 2)\n        ])\n\n        eye_size = 3\n        eye_offset = self.cell_size // 4\n        pygame.draw.circle(self.screen, (255, 255, 255), (head_x + eye_offset, head_y + eye_offset), eye_size)\n        pygame.draw.circle(self.screen, (255, 255, 255), (head_x + self.cell_size - eye_offset, head_y + eye_offset), eye_size)\n\n        # Draw the body (color gradient)\n        color_list = np.linspace(255, 100, len(self.snake), dtype=np.uint8)\n        i = 1\n        for r, c in self.snake[1:]:\n            body_x = c * self.cell_size + self.border_size\n            body_y = r * self.cell_size + self.border_size\n            body_width = self.cell_size\n            body_height = self.cell_size\n            body_radius = 5\n            pygame.draw.rect(self.screen, (0, color_list[i], 0),\n                            (body_x, body_y, body_width, body_height), border_radius=body_radius)\n            i += 1\n        pygame.draw.rect(self.screen, (255, 100, 100),\n                            (body_x, body_y, body_width, body_height), border_radius=body_radius)\n        \n\nif __name__ == \"__main__\":\n    import time\n\n    seed = random.randint(0, 1e9)\n    game = SnakeGame(seed=seed, silent_mode=False)\n    pygame.init()\n    game.screen = pygame.display.set_mode((game.display_width, game.display_height))\n    pygame.display.set_caption(\"Snake Game\")\n    game.font = pygame.font.Font(None, 36)\n    \n\n    game_state = \"welcome\"\n\n    # Two hidden button for start and retry click detection\n    start_button = game.font.render(\"START\", True, (0, 0, 0))\n    retry_button = game.font.render(\"RETRY\", True, (0, 0, 0))\n\n    update_interval = 0.15\n    start_time = time.time()\n    action = -1\n\n    while True:\n        \n        for event in pygame.event.get():\n\n            if game_state == \"running\":\n                if event.type == pygame.KEYDOWN:\n                    if event.key == pygame.K_UP:\n                        action = 0\n                    elif event.key == pygame.K_DOWN:\n                        action = 3\n                    elif event.key == pygame.K_LEFT:\n                        action = 1\n                    elif event.key == pygame.K_RIGHT:\n                        action = 2\n\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n            if game_state == \"welcome\" and event.type == pygame.MOUSEBUTTONDOWN:\n                if game.is_mouse_on_button(start_button):\n                    for i in range(3, 0, -1):\n                        game.screen.fill((0, 0, 0))\n                        game.draw_countdown(i)\n                        game.sound_eat.play()\n                        pygame.time.wait(1000)\n                    action = -1  # Reset action variable when starting a new game\n                    game_state = \"running\"\n\n            if game_state == \"game_over\" and event.type == pygame.MOUSEBUTTONDOWN:\n                if game.is_mouse_on_button(retry_button):\n                    for i in range(3, 0, -1):\n                        game.screen.fill((0, 0, 0))\n                        game.draw_countdown(i)\n                        game.sound_eat.play()\n                        pygame.time.wait(1000)\n                    game.reset()\n                    action = -1  # Reset action variable when starting a new game\n                    game_state = \"running\"\n        \n        if game_state == \"welcome\":\n            game.draw_welcome_screen()\n\n        if game_state == \"game_over\":\n            game.draw_game_over_screen()\n\n        if game_state == \"running\":\n            if time.time() - start_time >= update_interval:\n                done, _ = game.step(action)\n                game.render()\n                start_time = time.time()\n\n                if done:\n                    game_state = \"game_over\"\n        \n        pygame.time.wait(1)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main/snake_game.py b/main/snake_game.py
--- a/main/snake_game.py	(revision a067bfc10df56a16ee601d47c5736a7fa41a1a64)
+++ b/main/snake_game.py	(date 1737302211740)
@@ -27,10 +27,10 @@
             self.font = pygame.font.Font(None, 36)
 
             # Load sound effects
-            mixer.init()
-            self.sound_eat = mixer.Sound("sound/eat.wav")
-            self.sound_game_over = mixer.Sound("sound/game_over.wav")
-            self.sound_victory = mixer.Sound("sound/victory.wav")
+            # mixer.init()
+            # self.sound_eat = mixer.Sound("sound/eat.wav")
+            # self.sound_game_over = mixer.Sound("sound/game_over.wav")
+            # self.sound_victory = mixer.Sound("sound/victory.wav")
         else:
             self.screen = None
             self.font = None
@@ -72,8 +72,8 @@
         if (row, col) == self.food: # If snake eats food, it won't pop the last cell. The food grid will be taken by snake later, no need to update board vacancy matrix.
             food_obtained = True
             self.score += 10 # Add 10 points to the score when food is eaten.
-            if not self.silent_mode:
-                self.sound_eat.play()
+            # if not self.silent_mode:
+            #     self.sound_eat.play()
         else:
             food_obtained = False
             self.non_snake.add(self.snake.pop()) # Pop the last cell of the snake and add it to the non-snake set.
@@ -91,12 +91,12 @@
             self.snake.insert(0, (row, col))
             self.non_snake.remove((row, col))
 
-        else: # If game is over and the game is not in silent mode, play game over sound effect.
-            if not self.silent_mode:
-                if len(self.snake) < self.grid_size:
-                    self.sound_game_over.play()
-                else:
-                    self.sound_victory.play()
+        # else: # If game is over and the game is not in silent mode, play game over sound effect.
+        #     if not self.silent_mode:
+        #         if len(self.snake) < self.grid_size:
+        #             self.sound_game_over.play()
+        #         else:
+        #             self.sound_victory.play()
 
         # Add new food after snake movement completes.
         if food_obtained:
@@ -290,7 +290,7 @@
                     for i in range(3, 0, -1):
                         game.screen.fill((0, 0, 0))
                         game.draw_countdown(i)
-                        game.sound_eat.play()
+                        #game.sound_eat.play()
                         pygame.time.wait(1000)
                     action = -1  # Reset action variable when starting a new game
                     game_state = "running"
@@ -300,7 +300,7 @@
                     for i in range(3, 0, -1):
                         game.screen.fill((0, 0, 0))
                         game.draw_countdown(i)
-                        game.sound_eat.play()
+                        #game.sound_eat.play()
                         pygame.time.wait(1000)
                     game.reset()
                     action = -1  # Reset action variable when starting a new game
